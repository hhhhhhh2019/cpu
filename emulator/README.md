Эмулятор для моего процессора(пока только виртуальный) на моей архитектуре(названия нет).

Кеша у процессора не будет(покарайней мере пока), ОЗУ на процессоре.

В этой архитектуре пытаюсь достичь идеала между минимализмом и удобством.

С RISC-V и ARM не знаком.



# Регистры

Есть 2 регистровых файла(потом РФ)(SIMD регистров пока нет, для них все будет также) и один общий регистр.

Один РФ используется обычными программами, запсь в регистры flag и tp запрещена.

Второй РФ используется BIOS-ом, загрузчиком и ядром(прерывания тоже), регистры этого файла и инструкции для работы с ними имеют постфикс k.

Обращатся можно только к целому регистру, ah,al,eax,rax как в amd64 нет.

Регистр r0 всегда содержит 0.

- pc - r15
- sp - r14


# Состояния

Хранится в общем регистре state, запись в него доступна только к KERNEL_MODE.

|состояние|бит|описание|
|-|:-:|-|
|ENABLE|0|включено ли ядро|
|INTERRUPTS|1|включены ли прерывания|
|PAGING|2|включены ли вируальные адреса|
|NORMAL_MODE|3|этот бит выключен -> KERNEL_MODE включен. Определяет используемый регистровый файл|


# Флаги

|название|бит|описание|
|-|:-:|-|
|ZERO|1||
|CARRY|2||
|SIGN|3|знак результата при вычитании|


# Инструкции

## Аргументы

- r - регистр, 4 бита
- numN - число, N бит


## Расположение в памяти

r в длинну 4 бита, по этому инструкии с нечетным количеством регистров будут выглятедь так:
||mov|r|nothing|number|
|-|:-:|:-:|:-:|:-:|
|размер в битах|8|4|4|64|


## Инструкции

|номер|название|аргументы|описание|
|-:|:-:|:-:|-|
|00|stol|r r num64|записать значение первого регистра в ОЗУ по (адресу из второго + смещение)|
|01|stoi|r r num64|записать младшие 32 бита значения первого регистра в ОЗУ по (адресу из второго + смещение)|
|02|stos|r r num64|записать младшие 16 бит значения первого регистра в ОЗУ по (адресу из второго + смещение)|
|03|stob|r r num64|записать младшие 8 бит значения первого регистра в ОЗУ по (адресу из второго + смещение)|
|04|loal|r r num64|прочитать 64 битное число, из ОЗУ по (адресу из второго + смещение) в первый регистр|
|05|loai|r r num64|прочитать 32 битное число, из ОЗУ по (адресу из второго + смещение) в первый регистр|
|06|loas|r r num64|прочитать 16 битное число, из ОЗУ по (адресу из второго + смещение) в первый регистр|
|07|loab|r r num64|прочитать 8 битное число, из ОЗУ по (адресу из второго + смещение) в первый регистр|
|08|add|r r r|сложить значения второго и третьего регистров и записать результат в первый|
|09|sub|r r r|вычесть значение третьего регистра из второго и записать результат в первый|
|0a|mul|r r r|перемножить значения второго и третьего регистров и записать результат в первый|
|0b|div|r r r|разделить значение второго регистра на значение третьего и записать результат в первый|
|0c|smul|r r r|перемножить значения(с учетом знака) второго и третьего регистров и записать результат в первый|
|0d|sdiv|r r r|разделить значение(с учетом знака) второго регистра на значение третьего и записать результат в первый|
|0x0e|add|r r num64||
|0x0f|sub|r r num64||
|0x10|mul|r r num64||
|0x11|div|r r num64||
|0x12|smul|r r num64||
|0x13|sdiv|r r num64||
|0x14|adde|r r num64|сложить значение второго регистра и числа, и записать результат в первый, если включен флаг ZERO|
|0x15|addne|r r num64|сложить значение второго регистра и числа, и записать результат в первый, если выключен флаг ZERO|
|0x16|addl|r r num64|сложить значение второго регистра и числа, и записать результат в первый, если включен флаг CARRY|
|0x17|addg|r r num64|сложить значение второго регистра и числа, и записать результат в первый, если флаги CARRY и ZERO выключены|
|0x18|addsl|r r num64|сложить значение второго регистра и числа, и записать результат в первый, если флаг включен SIGN|
|0x19|addsg|r r num64|сложить значение второго регистра и числа, и записать результат в первый, если флаги SIGN и ZERO выключены|
|0x1a|pushl|r||
|0x1b|pushi|r||
|0x1c|pushs|r||
|0x1d|pushb|r||
|0x1e|popl|r||
|0x1f|popi|r||
|0x20|pops|r||
|0x21|popb|r||
|0x22|call|r||
|0x23|int|num8||
|0x24|iret|||
|0x25|and|r r r||
|0x26|or|r r r||
|0x27|xor|r r r||
|0x28|not|r r||
|0x29|shl|r r r||
|0x2a|shr|r r r||
|0x2b|and|r r num64||
|0x2c|or|r r num64||
|0x2d|xor|r r num64||
|0x2e|shl|r r num64||
|0x2f|shr|r r num64||
|0x30|chst|r|записать в state|
|0x31|lost|r|прочитать из state|
|0x32|stolk|r r num64|записать значение первого регистра(из РФ без постфикса k) в ОЗУ по адресу из второго(из РФ с постфиксом k)|
|0x33|loalk|r r num64|прочитать 64 битное число, из ОЗУ по адресу из второго регистра(из РФ без постфикса k) в первый регистр(из РФ с постфиксом k)|
|0x34|chtp|r|записать в tp(из РФ без постфикса k)|
|0x35|lotp|r|прочитать из tp(из РФ без постфикса k)|
|0x36|chflag|r|записать в flag(из РФ без постфикса k)|
|0x37|loflag|r|прочитать из flag(из РФ без постфикса k)|
|0x38|cint|num8 num8|вызов прерывания на другом ядре|


# Прерывания

Таблица прерываний начинается с адреса 0x0 и представляет из себя массив из 256 элементова.
Каждый элемент этого массива является 64 битным адресом на обработчик соответствующего прерывания.


# Виртуальные адреса

4 уровня таблиц:
|биты||
|:-:|:-:|
|0-15|смещение в странице|
|16-31|индекс в 0 таблице|
|32-47|индекс в 1 таблице|
|48-55|индекс в 2 таблице|
|56-63|индекс в 3 таблице|

Элементы в таблицах 3,2,1 - адреса следующих таблиц

Элементы в 0 таблице:
- 0-59 - адрес страницы
- 60 - запуск кода
- 61 - чтение
- 62 - запись
- 63 - инициализорована ли страница


<img src="https://github.com/hhhhhhh2019/cpu/blob/master/assets/paging.png"></img>


# MMU

Не знаю как должно быть, но у меня mmu занимается mmio и виртуальными адресами.

- аргумент vaddr указывает: использовать ли виртуальные адреса
- аргумент tp указывает на адрес 3 таблицы
