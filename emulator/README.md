Эмулятор для моего процессора(пока только виртуальный) на моей архитектуре(названия нет).

Кеша у процессора не будет(покарайней мере пока), ОЗУ на процессоре.

В этой архитектуре пытаюсь достичь идеала между минимализмом и удобством.

С RISC-V и ARM не знаком.



# Регистры

Есть 2 регистровых файла(потом РФ)(SIMD регистров пока нет, для них все будет также) и один общий регистр.

Один РФ используется обычными программами, запсь в регистры flag и tp запрещена.

Второй РФ используется BIOS-ом, загрузчиком и ядром(прерывания тоже), регистры этого файла и инструкции для работы с ними имеют постфикс k.

Обращатся можно только к целому регистру, ah,al,eax,rax как в amd64 нет.

Регистр r0 всегда содержит 0.

- pc - r15
- sp - r14


# Состояния

Хранится в общем регистре state, запись в него доступна только к KERNEL_MODE.

|состояние|бит|описание|
|-|:-:|-|
|ENABLE|0|включено ли ядро|
|INTERRUPTS|1|включены ли прерывания|
|PAGING|2|включены ли вируальные адреса|
|NORMAL_MODE|3|этот бит выключен -> KERNEL_MODE включен. Определяет используемый регистровый файл|


# Флаги

|название|бит|описание|
|-|:-:|-|
|ZERO|1||
|CARRY|2||
|OVERFLOW|4||


# Инструкции

## Аргументы

- r - регистр, 4 бита
- numN - число, N бит


## Расположение в памяти

r в длинну 4 бита, по этому инструкии с нечетным количеством регистров будут выглятедь так:
||mov|r|nothing|number|
|-|:-:|:-:|:-:|:-:|
|размер в битах|8|4|4|64|


## Инструкции

|номер|название|аргументы|описание|
|-:|:-:|:-:|-|
|00|stol|r r num64|записать значение первого регистра в ОЗУ по (адресу из второго + смещение)|
|01|stoi|r r num64|записать младшие 32 бита значения первого регистра в ОЗУ по (адресу из второго + смещение)|
|02|stos|r r num64|записать младшие 16 бит значения первого регистра в ОЗУ по (адресу из второго + смещение)|
|03|stob|r r num64|записать младшие 8 бит значения первого регистра в ОЗУ по (адресу из второго + смещение)|
|04|loal|r r num64|прочитать 64 битное число, из ОЗУ по (адресу из второго + смещение) в первый регистр|
|05|loai|r r num64|прочитать 32 битное число, из ОЗУ по (адресу из второго + смещение) в первый регистр|
|06|loas|r r num64|прочитать 16 битное число, из ОЗУ по (адресу из второго + смещение) в первый регистр|
|07|loab|r r num64|прочитать 8 битное число, из ОЗУ по (адресу из второго + смещение) в первый регистр|
|08|add|r r r|сложить значения второго и третьего регистров и записать результат в первый|
|09|sub|r r r|вычесть значение третьего регистра из второго и записать результат в первый|
|0a|mul|r r r|перемножить значения второго и третьего регистров и записать результат в первый|
|0b|div|r r r|разделить значение второго регистра на значение третьего и записать результат в первый|
|0c|smul|r r r|перемножить значения(с учетом знака) второго и третьего регистров и записать результат в первый|
|0d|sdiv|r r r|разделить значение(с учетом знака) второго регистра на значение третьего и записать результат в первый|
|0e|cmp|r r|сравнить значения двух регистров|
|0f|add|r r num64||
|10|sub|r r num64||
|11|mul|r r num64||
|12|div|r r num64||
|13|smul|r r num64||
|14|sdiv|r r num64||
|15|cmp|r num64||
|16|je|num64|переход, если включен флаг ZERO|
|17|jne|num64|переход, если выключен флаг ZERO|
|18|jl|num64|переход, если включен флаг CARRY|
|19|jg|num64|переход, если CARRY и ZERO выключены|
|1a|jo|num64|переход, если включен флаг OVERFLOW|
|1b|jno|num64|переход, если выключен флаг OVERFLOW|
|1c|pushl|r||
|1d|pushi|r||
|1e|pushs|r||
|1f|pushb|r||
|20|popl|r||
|21|popi|r||
|22|pops|r||
|23|popb|r||
|24|call|r||
|25|int|num8||
|26|iret|||
|27|and|r r r||
|28|or|r r r||
|29|xor|r r r||
|2a|not|r r||
|2b|shl|r r r||
|2c|shr|r r r||
|2d|and|r r num64||
|2e|or|r r num64||
|2f|xor|r r num64||
|30|shl|r r num64||
|31|shr|r r num64||
|32|chst|r|записать в state|
|33|lost|r|прочитать из state|
|34|stolk|r r num64|записать значение первого регистра(из РФ без постфикса k) в ОЗУ по адресу из второго(из РФ с постфиксом k)|
|35|loalk|r r num64|прочитать 64 битное число, из ОЗУ по адресу из второго регистра(из РФ без постфикса k) в первый регистр(из РФ с постфиксом k)|
|36|chtp|r|записать в tp(из РФ без постфикса k)|
|37|lotp|r|прочитать из tp(из РФ без постфикса k)|
|38|chflag|r|записать в flag(из РФ без постфикса k)|
|39|loflag|r|прочитать из flag(из РФ без постфикса k)|


# Прерывания

Таблица прерываний начинается с адреса 0x0 и представляет из себя массив из 256 элементова.
Каждый элемент этого массива является 64 битным адресом на обработчик соответствующего прерывания.


# Виртуальные адреса

4 уровня таблиц:
|биты||
|:-:|:-:|
|0-15|смещение в странице|
|16-31|индекс в 0 таблице|
|32-47|индекс в 1 таблице|
|48-55|индекс в 2 таблице|
|56-63|индекс в 3 таблице|

Элементы в таблицах 3,2,1 - адреса следующих таблиц

Элементы в 0 таблице:
- 0-59 - адрес страницы
- 60 - запуск кода
- 61 - чтение
- 62 - запись
- 63 - инициализорована ли страница


# MMU

Не знаю как должно быть, но у меня mmu занимается mmio и виртуальными адресами.

- аргумент vaddr указывает: использовать ли виртуальные адреса
- аргумент tp указывает на адрес 3 таблицы
